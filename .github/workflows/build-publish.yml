name: Build, Test and Publish ITL ControlPlane SDK

on:
  workflow_dispatch:
    inputs:
      publish_pypi:
        description: 'Publish to PyPI'
        required: false
        default: true
        type: boolean
  push:
    tags:
      - "v*"
    paths: 
      - 'src/**'
      - 'pyproject.toml'
      - 'README.md'
      - 'LICENSE'
      - '.github/workflows/**'

env:
  PACKAGE_NAME: itl-controlplane-sdk
  PYTHON_VERSION: '3.11'

jobs:
  # Lint and security checks
  lint-and-security:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install security tools
      run: |
        python -m pip install --upgrade pip
        pip install bandit safety pip-audit

    - name: Install package
      run: |
        pip install -e ".[dev]"

    - name: Run bandit security linter
      run: |
        bandit -r src/ -f json -o bandit-report.json || true
        bandit -r src/ 

    - name: Run safety check for dependencies
      run: |
        safety check --json --output safety-report.json || true
        safety check

    - name: Run pip-audit for vulnerability scanning
      run: |
        pip-audit --format=json --output=audit-report.json || true
        pip-audit

    - name: Upload security reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-reports
        path: |
          bandit-report.json
          safety-report.json
          audit-report.json
        retention-days: 30

  # Build and package
  build:
    needs: [lint-and-security]
    runs-on: ubuntu-latest
    if: ${{ always() && (needs.lint-and-security.result == 'success') }}
    
    outputs:
      package-version: ${{ steps.version.outputs.version }}
      wheel-name: ${{ steps.build.outputs.wheel-name }}
      sdist-name: ${{ steps.build.outputs.sdist-name }}
      is-release: ${{ steps.version.outputs.is-release }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for version detection

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install build tools
      run: |
        python -m pip install --upgrade pip
        pip install build twine wheel tomli tomli-w

    - name: Detect version context
      id: version
      run: |
        # Determine if this is a release
        IS_RELEASE=false
        if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          IS_RELEASE=true
          echo "ðŸ·ï¸ RELEASE BUILD DETECTED"
        else
          echo "ðŸ”§ Development build"
        fi
        
        # Get version information
        if [[ "$IS_RELEASE" == "true" ]]; then
          # Extract version from tag (v1.2.3 -> 1.2.3)
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"
          echo "ðŸ“Œ Release version from tag: $VERSION"
        else
          # Get base version from pyproject.toml
          if python3 -c "import sys; sys.version_info >= (3,11)" 2>/dev/null; then
            BASE_VERSION=$(python -c "
              import tomllib
              with open('pyproject.toml', 'rb') as f:
                data = tomllib.load(f)
              print(data['project']['version'])
            ")
          else
            BASE_VERSION=$(python -c "
              import tomli
              with open('pyproject.toml', 'rb') as f:
                data = tomli.load(f)
              print(data['project']['version'])
            ")
          fi
          
          # Build development version with branch context
          BRANCH="${{ github.ref_name }}"
          SHA="${{ github.sha }}"
          SHA_SHORT="${SHA:0:7}"
          RUN_NUM="${{ github.run_number }}"
          
          # Add branch-specific suffix
          if [[ "$BRANCH" == "main" ]]; then
            VERSION="${BASE_VERSION}.dev${RUN_NUM}+main.${SHA_SHORT}"
          elif [[ "$BRANCH" == "develop" ]]; then
            VERSION="${BASE_VERSION}.dev${RUN_NUM}+develop.${SHA_SHORT}"
          elif [[ "$BRANCH" == feature/* ]]; then
            # Feature branch: v1.2.3.dev123+feature.branch-name.abc1234
            FEATURE_NAME="${BRANCH#feature/}"
            FEATURE_NAME="${FEATURE_NAME//\//-}"
            VERSION="${BASE_VERSION}.dev${RUN_NUM}+feature.${FEATURE_NAME}.${SHA_SHORT}"
          else
            # Other branches
            CLEAN_BRANCH="${BRANCH//\//-}"
            VERSION="${BASE_VERSION}.dev${RUN_NUM}+${CLEAN_BRANCH}.${SHA_SHORT}"
          fi
          
          echo "ðŸ“Œ Development version: $VERSION"
        fi
        
        # Output version information
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "is-release=$IS_RELEASE" >> $GITHUB_OUTPUT
        echo "branch=${{ github.ref_name }}" >> $GITHUB_OUTPUT

    - name: Update pyproject.toml with version
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        IS_RELEASE="${{ steps.version.outputs.is-release }}"
        
        echo "ðŸ“ Setting version to: $VERSION (Release: $IS_RELEASE)"
        
        python -c "
        import tomli_w
        try:
          import tomllib
          with open('pyproject.toml', 'rb') as f:
            data = tomllib.load(f)
        except ImportError:
          import tomli
          with open('pyproject.toml', 'rb') as f:
            data = tomli.load(f)
        
        data['project']['version'] = '$VERSION'
        
        with open('pyproject.toml', 'wb') as f:
          tomli_w.dump(data, f)
        
        print(f'âœ… Updated pyproject.toml to version: $VERSION')
        "

    - name: Display version information
      run: |
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ðŸ“‹ VERSION INFORMATION"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Version: ${{ steps.version.outputs.version }}"
        echo "Is Release: ${{ steps.version.outputs.is-release }}"
        echo "Branch: ${{ steps.version.outputs.branch }}"
        echo "GitHub Ref: ${{ github.ref }}"
        echo "GitHub Event: ${{ github.event_name }}"
        
        # Verify in pyproject.toml
        echo ""
        echo "Current pyproject.toml version:"
        python -c "
        try:
          import tomllib
          with open('pyproject.toml', 'rb') as f:
            data = tomllib.load(f)
        except ImportError:
          import tomli
          with open('pyproject.toml', 'rb') as f:
            data = tomli.load(f)
        print(f\"  {data['project']['version']}\")
        "
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    - name: Build package
      id: build
      run: |
        echo "ðŸ“¦ Building Python package..."
        python -m build --sdist --wheel --outdir dist/
        
        # Get the built file names
        WHEEL_NAME=$(ls dist/*.whl | head -1 | xargs basename)
        SDIST_NAME=$(ls dist/*.tar.gz | head -1 | xargs basename)
        
        echo "wheel-name=$WHEEL_NAME" >> $GITHUB_OUTPUT
        echo "sdist-name=$SDIST_NAME" >> $GITHUB_OUTPUT
        
        echo "âœ… Built packages:"
        ls -la dist/
        
        # Verify the package
        echo "ðŸ” Verifying package contents..."
        python -m zipfile -l "dist/$WHEEL_NAME"

    - name: Test package installation
      run: |
        echo "ðŸ§ª Testing package installation..."
        # Create a clean environment to test installation
        python -m venv test-env
        source test-env/bin/activate
        
        # Install from wheel
        pip install dist/*.whl
        
        # Test import
        python -c "
        from itl_controlplane_sdk import ResourceProviderRegistry, ResourceProvider
        from itl_controlplane_sdk.models import ResourceRequest, ProvisioningState
        print('âœ… Package installation and import test successful')
        "
        
        deactivate
        rm -rf test-env

    - name: Check package metadata
      run: |
        echo "ðŸ“‹ Checking package metadata..."
        python -m twine check dist/*

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: python-package-${{ steps.version.outputs.version }}
        path: dist/
        retention-days: 30

  # Publish to PyPI (Test)
  publish-test:
    needs: [build]
    runs-on: ubuntu-latest
    if: ${{ always() && needs.build.result == 'success' }}
    environment: staging
    
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: python-package-${{ needs.build.outputs.package-version }}
        path: dist/

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install publish tools
      run: |
        python -m pip install --upgrade pip
        pip install twine

    - name: Publish to Test PyPI
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.TEST_PYPI_TOKEN }}
        TWINE_REPOSITORY_URL: https://test.pypi.org/legacy/
      run: |
        echo "ðŸš€ Publishing to Test PyPI..."
        python -m twine upload dist/* --verbose

    - name: Test installation from Test PyPI
      run: |
        echo "ðŸ§ª Testing installation from Test PyPI..."
        # Wait a bit for package to be available
        sleep 30
        
        # Create clean environment
        python -m venv test-install-env
        source test-install-env/bin/activate
        
        # Install from Test PyPI (may fail if dependencies aren't available)
        pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ ${{ env.PACKAGE_NAME }}==${{ needs.build.outputs.package-version }} || echo "Test PyPI installation failed (expected for dev versions)"
        
        deactivate
        rm -rf test-install-env

  # Publish to PyPI (Production)
  publish-production:
    needs: [build, test, publish-test]
    runs-on: ubuntu-latest
    if: |
      startsWith(github.ref, 'refs/tags/v') && 
      (
        (github.event_name == 'workflow_dispatch' && inputs.publish_pypi) ||
        github.event_name != 'workflow_dispatch'
      )
    environment: production
    permissions:
      contents: write
      id-token: write  # For trusted publishing
    
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: python-package-${{ needs.build.outputs.package-version }}
        path: dist/

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install publish tools
      run: |
        python -m pip install --upgrade pip
        pip install twine

    - name: Publish to PyPI
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}
      run: |
        echo "ðŸš€ Publishing to PyPI..."
        python -m twine upload dist/* --verbose

    - name: Verify PyPI publication
      run: |
        echo "âœ… Verifying PyPI publication..."
        # Wait for package to be available
        sleep 60
        
        # Try to install from PyPI
        python -m venv verify-env
        source verify-env/bin/activate
        pip install ${{ env.PACKAGE_NAME }}==${{ needs.build.outputs.package-version }}
        
        # Test import
        python -c "
        from itl_controlplane_sdk import ResourceProviderRegistry, ResourceProvider
        print('âœ… PyPI package verification successful')
        "
        
        deactivate
        rm -rf verify-env

  # Create GitHub Release
  create-release:
    needs: [build, test, publish-production]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: python-package-${{ needs.build.outputs.package-version }}
        path: dist/

    - name: Generate release notes
      run: |
        cat > release-notes.md << EOF
        # ITL ControlPlane SDK ${{ github.ref_name }}
        
        ## ðŸ“¦ Package Information
        - **Version**: ${{ needs.build.outputs.package-version }}
        - **Python Support**: 3.8+
        - **PyPI**: https://pypi.org/project/${{ env.PACKAGE_NAME }}/${{ needs.build.outputs.package-version }}/
        
        ## ðŸš€ Installation
        
        \`\`\`bash
        pip install ${{ env.PACKAGE_NAME }}==${{ needs.build.outputs.package-version }}
        \`\`\`
        
        ## ðŸ“š Quick Start
        
        \`\`\`python
        from itl_controlplane_sdk import ResourceProviderRegistry, ResourceProvider
        from itl_controlplane_sdk.models import ResourceRequest
        
        # Create registry and register providers
        registry = ResourceProviderRegistry()
        # ... see examples/ for more details
        \`\`\`
        
        ## ðŸ“‹ What's Included
        - Core SDK package with resource provider framework
        - Provider base classes and interfaces
        - Data models for resource management
        - Example implementations
        
        ## ðŸ”— Links
        - [Documentation](https://github.com/${{ github.repository }}/blob/${{ github.ref_name }}/README.md)
        - [Examples](https://github.com/${{ github.repository }}/tree/${{ github.ref_name }}/examples)
        - [PyPI Package](https://pypi.org/project/${{ env.PACKAGE_NAME }}/)
        
        ## ðŸ“ Release Assets
        - **Source Distribution** (.tar.gz): For pip installation from source
        - **Python Wheel** (.whl): For fast binary installation
        EOF

    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref_name }}
        release_name: ITL ControlPlane SDK ${{ github.ref_name }}
        body_path: release-notes.md
        draft: false
        prerelease: ${{ contains(github.ref_name, '-') }}

    - name: Upload release assets
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: dist/${{ needs.build.outputs.wheel-name }}
        asset_name: ${{ needs.build.outputs.wheel-name }}
        asset_content_type: application/zip

    - name: Upload source distribution
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: dist/${{ needs.build.outputs.sdist-name }}
        asset_name: ${{ needs.build.outputs.sdist-name }}
        asset_content_type: application/gzip

  # Auto-create release tags on push to main/develop
  auto-tag:
    needs: [build]
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' &&
      !startsWith(github.ref, 'refs/tags/') &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    permissions:
      contents: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Get current version and determine next version
      id: next-version
      run: |
        pip install tomli
        
        python << 'PYTHON_SCRIPT'
        import tomli
        import os
        
        # Get base version from pyproject.toml
        with open('pyproject.toml', 'rb') as f:
          data = tomli.load(f)
        
        current_version = data['project']['version']
        
        # Parse MAJOR.MINOR.PATCH
        parts = current_version.split('.')
        major = int(parts[0].split('-')[0].split('+')[0])
        minor = int(parts[1].split('-')[0].split('+')[0]) if len(parts) > 1 else 0
        patch = int(parts[2].split('-')[0].split('+')[0]) if len(parts) > 2 else 0
        
        # Determine bump strategy based on branch
        branch = os.getenv('GITHUB_REF')
        if 'refs/heads/main' in branch:
          # Main: bump minor version (1.0.0 -> 1.1.0)
          next_version = f"{major}.{minor + 1}.0"
          print("ðŸ“Œ Main branch: bumping minor version")
        else:
          # Develop: bump patch version (1.0.0 -> 1.0.1)
          next_version = f"{major}.{minor}.{patch + 1}"
          print("ðŸ“Œ Develop branch: bumping patch version")
        
        # Write outputs
        with open(os.getenv('GITHUB_OUTPUT'), 'a') as f:
          f.write(f"current={current_version}\n")
          f.write(f"next={next_version}\n")
          f.write(f"branch={os.getenv('GITHUB_REF_NAME')}\n")
        
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print("Version Bump Information")
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print(f"Current version: {current_version}")
        print(f"Next version: {next_version}")
        print(f"Branch: {os.getenv('GITHUB_REF_NAME')}")
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        PYTHON_SCRIPT

    - name: Check if tag already exists
      id: check-tag
      run: |
        TAG_NAME="v${{ steps.next-version.outputs.next }}"
        
        if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
          echo "âš ï¸ Tag $TAG_NAME already exists, skipping auto-tag"
          echo "tag-exists=true" >> $GITHUB_OUTPUT
        else
          echo "âœ… Tag $TAG_NAME does not exist, will create it"
          echo "tag-exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Update pyproject.toml with next version
      if: steps.check-tag.outputs.tag-exists == 'false'
      run: |
        pip install tomli tomli-w
        
        python -c "
        import tomli_w
        import tomli
        
        with open('pyproject.toml', 'rb') as f:
          data = tomli.load(f)
        
        data['project']['version'] = '${{ steps.next-version.outputs.next }}'
        
        with open('pyproject.toml', 'wb') as f:
          tomli_w.dump(data, f)
        
        print('âœ… Updated pyproject.toml to version: ${{ steps.next-version.outputs.next }}')
        "

    - name: Create and push tag
      if: steps.check-tag.outputs.tag-exists == 'false'
      run: |
        TAG_NAME="v${{ steps.next-version.outputs.next }}"
        
        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Commit version update
        git add pyproject.toml
        git commit -m "chore: bump version to ${{ steps.next-version.outputs.next }}"
        
        # Create and push tag
        git tag -a "$TAG_NAME" -m "Release ${{ steps.next-version.outputs.next }}"
        git push origin "$TAG_NAME"
        
        # Also push the version update commit
        git push origin ${{ steps.next-version.outputs.branch }}
        
        echo "âœ… Created and pushed tag: $TAG_NAME"
        echo ""
        echo "ðŸš€ This will automatically trigger the release workflow"
        echo "   Release will be published to PyPI and GitHub Releases"

    - name: Summary
      if: always()
      run: |
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ðŸ·ï¸ Auto-Tag Summary"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Branch: ${{ steps.next-version.outputs.branch }}"
        echo "Current version: ${{ steps.next-version.outputs.current }}"
        echo "Next version: ${{ steps.next-version.outputs.next }}"
        echo "Tag exists: ${{ steps.check-tag.outputs.tag-exists }}"
        if [[ "${{ steps.check-tag.outputs.tag-exists }}" == "false" ]]; then
          echo "Status: âœ… Tag created and pushed"
          echo "Next: Release workflow will be triggered automatically"
        else
          echo "Status: âš ï¸ Tag already exists, no action taken"
        fi
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

  # Notify on completion
  notify:
    needs: [build, publish-test, publish-production, create-release, auto-tag]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Determine notification status
      run: |
        if [[ "${{ needs.build.result }}" == "success" ]]; then
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            if [[ "${{ needs.publish-production.result }}" == "success" ]]; then
              echo "STATUS=âœ… PRODUCTION RELEASE SUCCESSFUL" >> $GITHUB_ENV
              echo "MESSAGE=ITL ControlPlane SDK ${{ github.ref_name }} successfully published to PyPI and GitHub Releases" >> $GITHUB_ENV
            else
              echo "STATUS=âŒ PRODUCTION RELEASE FAILED" >> $GITHUB_ENV
              echo "MESSAGE=Production release failed for ${{ github.ref_name }}" >> $GITHUB_ENV
            fi
          else
            if [[ "${{ needs.publish-test.result }}" == "success" ]]; then
              echo "STATUS=âœ… TEST BUILD SUCCESSFUL" >> $GITHUB_ENV
              echo "MESSAGE=ITL ControlPlane SDK test build completed successfully" >> $GITHUB_ENV
            else
              echo "STATUS=âš ï¸ TEST BUILD COMPLETED" >> $GITHUB_ENV
              echo "MESSAGE=ITL ControlPlane SDK build completed with warnings" >> $GITHUB_ENV
            fi
          fi
        else
          echo "STATUS=âŒ BUILD FAILED" >> $GITHUB_ENV
          echo "MESSAGE=ITL ControlPlane SDK build or tests failed" >> $GITHUB_ENV
        fi

    - name: Notify Teams (if webhook available)
      if: env.TEAMS_WEBHOOK
      run: |
        curl -H "Content-Type: application/json" -d '{
          "text": "${{ env.STATUS }}: ${{ env.MESSAGE }}",
          "sections": [
            {
              "activityTitle": "ITL ControlPlane SDK Pipeline",
              "activitySubtitle": "Build and Publish",
              "facts": [
                {"name": "Repository", "value": "${{ github.repository }}"},
                {"name": "Branch/Tag", "value": "${{ github.ref_name }}"},
                {"name": "Commit", "value": "${{ github.sha }}"},
                {"name": "Trigger", "value": "${{ github.event_name }}"}
              ]
            }
          ]
        }' ${{ env.TEAMS_WEBHOOK }}
      env:
        TEAMS_WEBHOOK: ${{ secrets.TEAMS_WEBHOOK }}

    - name: Summary
      run: |
        echo "ðŸŽ¯ Pipeline Summary"
        echo "=================="
        echo "Repository: ${{ github.repository }}"
        echo "Reference: ${{ github.ref }}"
        echo "Event: ${{ github.event_name }}"
        echo "Status: ${{ env.STATUS }}"
        echo "Message: ${{ env.MESSAGE }}"
        echo ""
        echo "Job Results:"
        echo "- Test: ${{ needs.test.result }}"
        echo "- Build: ${{ needs.build.result }}"
        echo "- Publish Test: ${{ needs.publish-test.result }}"
        echo "- Publish Production: ${{ needs.publish-production.result }}"
        echo "- Create Release: ${{ needs.create-release.result }}"